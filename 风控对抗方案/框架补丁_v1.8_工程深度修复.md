# æ¡†æ¶è¡¥ä¸ v1.8 â€” äº”å¤§å·¥ç¨‹æ·±åº¦ä¿®å¤

> **æœ¬æ–‡æ¡£æ˜¯ä¸»æ–‡æ¡£ `æ¡†æ¶è®¾è®¡æ–‡æ¡£_v1.md`ï¼ˆv1.7ï¼‰çš„è¡¥ä¸é›†**ï¼Œä¸é‡å¤å™è¿°å·²æœ‰è®¾è®¡ã€‚  
> æ¯ä¸ª Patch æ³¨æ˜ï¼šå½±å“çš„ä¸»æ–‡æ¡£ç« èŠ‚ / æ–°å¢ DB å­—æ®µ / æ–°å¢ä¾èµ–ã€‚  
> é—®é¢˜æ¥æºï¼šç¬¬å››è½®å·¥ç¨‹å®¡è®¡ï¼Œ5 ä¸ª P0/P1 çº§ç›²ç‚¹ã€‚

---

## ç›®å½•

1. [Patch 1ï¼šWeb3 Nonce ç®¡ç†å™¨ä¸ Pending è‡ªæ„ˆæœºåˆ¶](#patch-1)
2. [Patch 2ï¼šç³»ç»Ÿèµ„æºæ¢é’ˆä¸å¹¶å‘ç†”æ–­å™¨](#patch-2)
3. [Patch 3ï¼šMetaMask ç‰ˆæœ¬é”å®šä¸ DOM å°è£…ï¼ˆæ›¿ä»£ Synpressï¼‰](#patch-3)
4. [Patch 4ï¼šç§é’¥è¿è¡Œæ—¶åŠ è½½â€”â€”ä¸è½ç›˜æ–¹æ¡ˆ](#patch-4)
5. [Patch 5ï¼šé¼ æ ‡è¡Œä¸ºç†µå€¼æå‡â€”â€”å¤šç­–ç•¥æ··åˆ](#patch-5)

---

## Patch 1ï¼šWeb3 Nonce ç®¡ç†å™¨ä¸ Pending è‡ªæ„ˆæœºåˆ¶ {#patch-1}

**å½±å“ç« èŠ‚**ï¼šä¸»æ–‡æ¡£ Â§4.4 Layer 2B Web3 æ‰§è¡Œå¼•æ“  
**é—®é¢˜**ï¼šæ¡†æ¶æŠŠé“¾ä¸Šäº¤äº’å½“ HTTP è¯·æ±‚å¤„ç†ã€‚120s è¶…æ—¶åä»…è®°å½• `tx_hash` ç­‰æ¬¡æ—¥å¤æŸ¥ï¼Œæœªå¤„ç† Nonce é˜»å¡ã€‚å•è´¦å·ä¸€ç¬” Pending äº¤æ˜“ = è¯¥è´¦å·åç»­æ‰€æœ‰ EVM äº¤æ˜“å…¨éƒ¨ Nonce å†²çªï¼Œ100 è´¦å·è§„æ¨¡ä¸‹é“¾æ‹¥å µæ—¶å…¨çº¿ç˜«ç—ªã€‚

### 1.1 æ–°å¢ DB è¡¨

```sql
-- è¿½è¸ªæ¯ç¬”é“¾ä¸Šäº¤æ˜“çš„ç”Ÿå‘½å‘¨æœŸï¼ˆåŒ…æ‹¬ speed-up / cancel æ›¿æ¢é“¾ï¼‰
CREATE TABLE pending_txns (
    id            INTEGER PRIMARY KEY AUTOINCREMENT,
    account_id    TEXT NOT NULL,
    chain_id      INTEGER NOT NULL,       -- 1=ETH, 8453=Base, 42161=Arbitrum
    nonce         INTEGER NOT NULL,
    tx_hash       TEXT,
    status        TEXT DEFAULT 'pending', -- pending|confirmed|replaced|cancelled|failed|nonce_stuck
    gas_price_wei TEXT,                   -- å­—ç¬¦ä¸²é¿å… INTEGER ç²¾åº¦æº¢å‡º
    submitted_at  TEXT,                   -- UTC ISO-8601
    resolved_at   TEXT,
    task_run_id   INTEGER,
    UNIQUE(account_id, chain_id, nonce),  -- åŒè´¦å·åŒé“¾åŒ Nonce å”¯ä¸€
    FOREIGN KEY (task_run_id) REFERENCES task_runs(id)
);
```

> `task_runs.failure_type` æ–°å¢æšä¸¾å€¼ `nonce_stuck`ï¼ˆå½’ç±»**ä¸å¯æ§**ï¼Œæ’é™¤ SLI åˆ†æ¯ï¼‰ã€‚

### 1.2 NonceManager æ ¸å¿ƒå®ç°

```python
# core/nonce_manager.py
import asyncio
from web3 import AsyncWeb3

class NonceManager:
    """å•è´¦å· Nonce åºåˆ—ç®¡ç†å™¨ã€‚æ¯ä¸ªè´¦å·å®ä¾‹åŒ–ä¸€ä¸ªï¼Œä¸è·¨è´¦å·å…±äº«ã€‚"""

    def __init__(self, account_id: str, address: str, chain_id: int,
                 w3: AsyncWeb3, db):
        self.account_id = account_id
        self.address    = address
        self.chain_id   = chain_id
        self.w3         = w3
        self.db         = db
        self._lock      = asyncio.Lock()

    async def get_next_nonce(self) -> int:
        async with self._lock:
            # 'pending' åŒ…å« mempool ä¸­æœªç¡®è®¤çš„äº¤æ˜“ï¼Œæ¯” 'latest' å‡†ç¡®
            return await self.w3.eth.get_transaction_count(
                self.address, block_identifier='pending'
            )

    async def record_submitted(self, nonce: int, tx_hash: str,
                               gas_price_wei: int, task_run_id: int):
        await self.db.write(
            "INSERT OR REPLACE INTO pending_txns "
            "(account_id,chain_id,nonce,tx_hash,gas_price_wei,submitted_at,task_run_id) "
            "VALUES (?,?,?,?,?,datetime('now'),?)",
            (self.account_id, self.chain_id, nonce,
             tx_hash, str(gas_price_wei), task_run_id)
        )

    async def wait_for_receipt(self, tx_hash: str,
                               timeout: int = 120,
                               poll_interval: int = 5) -> dict | None:
        """è¿”å› receipt dict æˆ– Noneï¼ˆè¶…æ—¶ï¼‰ã€‚ä¸æŠ›å¼‚å¸¸ã€‚"""
        deadline = asyncio.get_event_loop().time() + timeout
        while asyncio.get_event_loop().time() < deadline:
            try:
                receipt = await self.w3.eth.get_transaction_receipt(tx_hash)
                if receipt is not None:
                    st = 'confirmed' if receipt['status'] == 1 else 'failed'
                    await self.db.write(
                        "UPDATE pending_txns SET status=?,resolved_at=datetime('now') "
                        "WHERE tx_hash=?", (st, tx_hash)
                    )
                    return dict(receipt)
            except Exception:
                pass
            await asyncio.sleep(poll_interval)
        return None

    async def speed_up(self, nonce: int, bump_pct: float = 0.15) -> str | None:
        """
        Speed-upï¼šç›¸åŒ Nonce + Gas æé«˜ 15%ï¼Œå‘ 0 ETH ç»™è‡ªå·±æ›¿æ¢ mempool ä¸­çš„ pending äº¤æ˜“ã€‚
        EIP-1559 é“¾éœ€åŒæ—¶æé«˜ maxFeePerGas å’Œ maxPriorityFeePerGasã€‚
        """
        rows = await self.db.read(
            "SELECT gas_price_wei FROM pending_txns "
            "WHERE account_id=? AND chain_id=? AND nonce=? AND status='pending'",
            (self.account_id, self.chain_id, nonce)
        )
        if not rows:
            return None

        old_gas = int(rows[0][0])
        new_gas = int(old_gas * (1 + bump_pct))

        try:
            from core.secrets_vault import SecretsVault
            pk = SecretsVault.instance().get_pk(self.account_id)
            tx = {
                'from': self.address, 'to': self.address,
                'value': 0, 'nonce': nonce,
                'gasPrice': new_gas, 'gas': 21000,
                'chainId': self.chain_id,
            }
            signed   = self.w3.eth.account.sign_transaction(tx, private_key=pk)
            new_hash = (await self.w3.eth.send_raw_transaction(
                signed.rawTransaction
            )).hex()

            await self.db.write(
                "UPDATE pending_txns SET status='replaced',resolved_at=datetime('now') "
                "WHERE account_id=? AND chain_id=? AND nonce=? AND status='pending'",
                (self.account_id, self.chain_id, nonce)
            )
            await self.record_submitted(nonce, new_hash, new_gas, task_run_id=-1)
            return new_hash
        except Exception:
            await self.db.write(
                "UPDATE pending_txns SET status='nonce_stuck' "
                "WHERE account_id=? AND chain_id=? AND nonce=?",
                (self.account_id, self.chain_id, nonce)
            )
            return None
```

### 1.3 è°ƒç”¨æµç¨‹ï¼ˆé›†æˆç¤ºä¾‹ï¼‰

```python
async def run_web3_task(account, task, db):
    nm      = NonceManager(account['id'], account['address'],
                           task['chain_id'], build_w3(account), db)
    nonce   = await nm.get_next_nonce()
    tx_hash = await submit_via_metamask_dom(account, task, nonce)
    await nm.record_submitted(nonce, tx_hash, gas_price_wei=..., task_run_id=...)

    receipt = await nm.wait_for_receipt(tx_hash, timeout=120)
    if receipt is None:
        new_hash = await nm.speed_up(nonce, bump_pct=0.15)
        if new_hash:
            receipt = await nm.wait_for_receipt(new_hash, timeout=300)

    if receipt is None:
        # speed-up ä¹Ÿè¶…æ—¶ â†’ æ ‡è®° nonce_stuckï¼Œäººå·¥ä»‹å…¥ï¼Œä¸å‘èµ·åç»­ä»»åŠ¡
        await db.write(
            "UPDATE task_runs SET status='failed',failure_type='nonce_stuck',"
            "finished_at=datetime('now'),finished_date_utc=date('now') WHERE id=?",
            (task_run_id,)
        )
```

### 1.4 æ–°å¢ä¾èµ–

```
web3>=7.0.0    # pip install web3ï¼ˆæ”¯æŒ AsyncWeb3ï¼‰
```

---

## Patch 2ï¼šç³»ç»Ÿèµ„æºæ¢é’ˆä¸å¹¶å‘ç†”æ–­å™¨ {#patch-2}

**å½±å“ç« èŠ‚**ï¼šä¸»æ–‡æ¡£ Â§4.2 Layer 1 è°ƒåº¦å¼•æ“  
**é—®é¢˜**ï¼š`max_concurrent_accounts=8` æ— èµ„æºæ„ŸçŸ¥ã€‚å¸¦ MetaMask æ‰©å±•çš„ Headful Chrome å•å®ä¾‹ 300MB~1GB+ï¼Œ8 å¹¶å‘å¯è¾¾ 10GB+ã€‚OOM/Swap æ—¶ Playwright `TimeoutError` è¢«è¯¯åˆ†ç±»ä¸º `network`ï¼ˆå¯æ§ï¼Œè§¦å‘é‡è¯•ï¼‰â†’ è¶Šå¡è¶Šé‡è¯• â†’ é›ªå´©ã€‚

### 2.1 ResourceGuard

```python
# core/resource_guard.py
import asyncio, psutil, logging
logger = logging.getLogger(__name__)

class ResourceError(Exception):
    pass

class ResourceGuard:
    def __init__(self, max_slots=8, mem_limit_pct=85.0, cpu_limit_pct=90.0):
        self._sem        = asyncio.Semaphore(max_slots)
        self.mem_limit   = mem_limit_pct
        self.cpu_limit   = cpu_limit_pct

    def _ok(self) -> tuple[bool, str]:
        mem = psutil.virtual_memory()
        if mem.percent >= self.mem_limit:
            return False, f"MEM {mem.percent:.1f}%>={self.mem_limit}%"
        cpu = psutil.cpu_percent(interval=0.1)
        if cpu >= self.cpu_limit:
            return False, f"CPU {cpu:.1f}%>={self.cpu_limit}%"
        return True, "ok"

    async def acquire(self) -> bool:
        ok, reason = self._ok()
        if not ok:
            logger.warning("ResourceGuard BLOCKED: %s", reason)
            return False
        await self._sem.acquire()
        ok, reason = self._ok()   # åŒé‡æ£€æŸ¥
        if not ok:
            self._sem.release()
            logger.warning("ResourceGuard RELEASED (double-check): %s", reason)
            return False
        return True

    def release(self):
        self._sem.release()
```

### 2.2 è°ƒåº¦å™¨é›†æˆ

```python
_guard = ResourceGuard(max_slots=8, mem_limit_pct=85.0)

async def run_account_task(account, task, db):
    if not await _guard.acquire():
        # èµ„æºä¸è¶³ â†’ è®°å½• skipped+resource_exhaustionï¼Œæœ¬è½®è·³è¿‡ï¼Œä¸‹è½®å†è¯•
        await db.write(
            "INSERT INTO task_runs "
            "(account_id,task_id,status,failure_type,finished_at,finished_date_utc) "
            "VALUES (?,?,'skipped','resource_exhaustion',datetime('now'),date('now'))",
            (account['id'], task['id'])
        )
        return
    try:
        await _execute_task(account, task, db)
    finally:
        _guard.release()
```

### 2.3 failure_type è¡¥å…… & å‘Šè­¦ SQL

`resource_exhaustion` å½’ç±»**ä¸å¯æ§**ï¼Œæ’é™¤ SLI å¯æ§æˆåŠŸç‡åˆ†æ¯ã€‚ç‹¬ç«‹ç›‘æ§ï¼š

```sql
-- è¿ç»­ 3 æ¬¡èµ„æºç†”æ–­ â†’ è§¦å‘å‘Šè­¦ï¼ˆå»ºè®®é™ä½å¹¶å‘æˆ–æ‰©å®¹ï¼‰
SELECT finished_date_utc, COUNT(*) AS blocks
FROM task_runs
WHERE failure_type = 'resource_exhaustion'
GROUP BY finished_date_utc
HAVING blocks >= 3;
```

### 2.4 æ–°å¢ä¾èµ–

```
psutil>=5.9.0
```

---

## Patch 3ï¼šMetaMask ç‰ˆæœ¬é”å®šä¸ DOM å°è£…ï¼ˆæ›¿ä»£ Synpressï¼‰{#patch-3}

**å½±å“ç« èŠ‚**ï¼šä¸»æ–‡æ¡£ Â§4.4 Layer 2Bã€Â§9 ä¾èµ–æ¸…å•  
**é—®é¢˜**ï¼šSynpress æ˜¯ TypeScript æµ‹è¯•æ¡†æ¶ï¼Œé€šè¿‡ Pythonâ†’Node.js å­è¿›ç¨‹ IPC æ¡¥æ¥ï¼Œç»´æŠ¤æˆæœ¬é«˜ã€‚MetaMask UI æœˆå‡æ›´æ–°ï¼ŒDOM é€‰æ‹©å™¨ä¸ç¨³å®šã€‚Synpress è‡ªèº«éš MetaMask ç‰ˆæœ¬æœ‰å…¼å®¹æ€§æ–­è£‚é£é™©ã€‚

### 3.1 æ–¹æ¡ˆç»“è®º

```
æ”¾å¼ƒ Synpress + Node.js å­è¿›ç¨‹ã€‚æ”¹ä¸ºï¼š
  - å›ºå®šç‰ˆæœ¬ MetaMask CRXï¼ˆæœ¬åœ° .zip è§£å‹ï¼Œç¦æ­¢ Web Store æ›´æ–°ï¼‰
  - çº¯ Python Playwright + MetaMaskPage å°è£…ç±»ï¼ˆDOM é€‰æ‹©å™¨é›†ä¸­ç®¡ç†ï¼‰
ä¼˜åŠ¿ï¼šæŠ€æœ¯æ ˆç»Ÿä¸€ä¸º Pythonï¼ŒNode.js ä¾èµ–å…¨éƒ¨ç§»é™¤ï¼›å‡ç‰ˆæ—¶åªæ”¹ä¸€ä¸ªç±»ã€‚
```

### 3.2 CRX å›ºå®šåŠ è½½

```bash
# ä¸‹è½½æŒ‡å®šç‰ˆæœ¬ï¼ˆä» GitHub Releasesï¼‰
VERSION="11.9.6"
wget "https://github.com/MetaMask/metamask-extension/releases/download/v${VERSION}/metamask-chrome-${VERSION}.zip"
unzip "metamask-chrome-${VERSION}.zip" -d "extensions/metamask-v${VERSION}/"
```

```python
# core/browser_factory.py â€” Web3 æµè§ˆå™¨å¯åŠ¨ï¼ˆæ›¿æ¢åŸ Node.js æ–¹æ¡ˆï¼‰
from playwright.async_api import async_playwright
import pathlib

METAMASK_PATH = str(pathlib.Path("extensions/metamask-v11.9.6").resolve())

async def launch_web3_browser(account: dict, proxy: dict):
    playwright = await async_playwright().start()
    context = await playwright.chromium.launch_persistent_context(
        user_data_dir=account['metamask_profile_dir'],
        headless=False,   # MetaMask æ‰©å±•ä¸æ”¯æŒ headless=True
        args=[
            f"--disable-extensions-except={METAMASK_PATH}",
            f"--load-extension={METAMASK_PATH}",
            "--disable-component-updater",   # ç¦æ­¢ Chrome ç»„ä»¶/æ‰©å±•è‡ªåŠ¨æ›´æ–°
        ],
        proxy={"server": proxy['endpoint']},
    )
    return playwright, context
```

> **ä¸ºä½• `--load-extension=` å°±èƒ½é”ç‰ˆæœ¬**ï¼šé€šè¿‡æœ¬åœ°è·¯å¾„åŠ è½½çš„æ‰©å±•ä¸å— Chrome Web Store ç®¡ç†ï¼Œ`--disable-component-updater` è¿›ä¸€æ­¥é˜»æ­¢ Component Updater æ¨é€ï¼Œä¸¤è€…åˆå¹¶å¯å½»åº•é˜²æ­¢è‡ªåŠ¨æ›´æ–°ã€‚

### 3.3 MetaMaskPage å°è£…

```python
# core/metamask_page.py
import asyncio
from playwright.async_api import Page, BrowserContext

class MetaMaskPage:
    """
    MetaMask v11.x DOM å°è£…ã€‚ç‰ˆæœ¬å‡çº§æ—¶åªæ”¹é€‰æ‹©å™¨å¸¸é‡å—ã€‚
    """
    # â”€â”€ é€‰æ‹©å™¨å¸¸é‡ï¼ˆMetaMask v11.9.xï¼Œç‰ˆæœ¬å‡çº§æ—¶å¯¹ç…§ PR å˜æ›´æ›´æ–°ï¼‰â”€â”€
    _SEL_PASSWORD   = '[data-testid="unlock-password"]'
    _SEL_UNLOCK     = '[data-testid="unlock-submit"]'
    _SEL_SCROLL     = '[data-testid="signature-request-scroll-button"]'
    _SEL_SIGN       = '[data-testid="page-container-footer-next"]'
    _SEL_CONFIRM_TX = '[data-testid="page-container-footer-next"]'
    _SEL_CONNECT    = '[data-testid="page-container-footer-next"]'

    def __init__(self, ctx: BrowserContext, password: str):
        self._ctx = ctx
        self._pw  = password

    async def _mm_page(self, timeout_s: float = 10.0) -> Page:
        """å®šä½ MetaMask notification å¼¹çª—é¡µï¼ˆæœ€å¤šç­‰ timeout_s ç§’ï¼‰ã€‚"""
        deadline = asyncio.get_event_loop().time() + timeout_s
        while asyncio.get_event_loop().time() < deadline:
            for p in self._ctx.pages:
                if "notification.html" in p.url or "home.html" in p.url:
                    return p
            await asyncio.sleep(0.5)
        raise TimeoutError("MetaMask page not found")

    async def unlock(self):
        mm = await self._mm_page()
        await mm.fill(self._SEL_PASSWORD, self._pw)
        await mm.click(self._SEL_UNLOCK)
        await mm.wait_for_url("**/home.html*", timeout=10_000)

    async def connect(self, timeout_ms=15_000):
        mm = await self._mm_page()
        await mm.wait_for_selector(self._SEL_CONNECT, timeout=timeout_ms)
        await mm.click(self._SEL_CONNECT)

    async def sign(self, timeout_ms=20_000):
        mm = await self._mm_page()
        scroll = mm.locator(self._SEL_SCROLL)
        if await scroll.count() > 0:
            await scroll.click()
            await asyncio.sleep(0.5)
        await mm.wait_for_selector(self._SEL_SIGN, timeout=timeout_ms)
        await mm.click(self._SEL_SIGN)

    async def confirm_tx(self, timeout_ms=30_000):
        mm = await self._mm_page()
        await mm.wait_for_selector(self._SEL_CONFIRM_TX, timeout=timeout_ms)
        await mm.click(self._SEL_CONFIRM_TX)
```

### 3.4 ç‰ˆæœ¬å‡çº§ SOP

1. ä¸‹è½½æ–°ç‰ˆ zip â†’ `extensions/metamask-vX.Y.Z/`
2. è¿è¡Œ `scripts/verify_metamask_selectors.py`ï¼ˆè‡ªåŠ¨æ£€æŸ¥é€‰æ‹©å™¨æœ‰æ•ˆæ€§ï¼‰
3. æ›´æ–° `MetaMaskPage` ä¸­å¤±æ•ˆçš„é€‰æ‹©å™¨å¸¸é‡
4. æ›´æ–° `METAMASK_PATH` æŒ‡å‘æ–°ç‰ˆ
5. æ—§ç‰ˆç›®å½•ä¿ç•™ 30 å¤©å¤‡ç”¨

### 3.5 ä¾èµ–å˜æ›´

```diff
- Node.js å­è¿›ç¨‹ + Synpress æ–¹æ¡ˆï¼ˆå…¨éƒ¨ç§»é™¤ï¼‰
- package.jsonï¼ˆ@synthetixio/synpress, @playwright/test, js-yamlï¼‰
+ æ— æ–° Python ä¾èµ–ï¼ˆplaywright ä¸»æ–‡æ¡£å·²æœ‰ï¼‰
```

---

## Patch 4ï¼šç§é’¥è¿è¡Œæ—¶åŠ è½½â€”â€”ä¸è½ç›˜æ–¹æ¡ˆ {#patch-4}

**å½±å“ç« èŠ‚**ï¼šä¸»æ–‡æ¡£ Â§4.1 Layer 0 å®‰å…¨å­˜å‚¨  
**é—®é¢˜**ï¼š`WALLET_ENC_KEY` å­˜ `.env`ï¼Œä¸åŠ å¯†å¯†æ–‡åŒæœºã€‚æ”»å‡»è€…æ‹¿åˆ°ç›®å½• = å¯†é’¥ + å¯†æ–‡ = æ˜æ–‡ç§é’¥ã€‚Fernet åŠ å¯†ç­‰åŒæ‘†è®¾ã€‚

### 4.1 æ ¸å¿ƒåŸåˆ™

```
è§£å¯†å¯†é’¥ï¼ˆMaster Passwordï¼‰æ°¸è¿œä¸å†™å…¥ä»»ä½•æ–‡ä»¶ã€‚
å¯åŠ¨æ—¶ç”±äºº/Telegram Bot æ³¨å…¥å†…å­˜ï¼Œè§£å¯†åå­˜è¿›ç¨‹å†… dictã€‚
è¿›ç¨‹é‡å¯åå¿…é¡»é‡æ–°è§£é”ï¼›æ— äººå€¼å®ˆä¾èµ–æ–¹æ¡ˆ Bã€‚
```

### 4.2 vault æ–‡ä»¶æ ¼å¼ï¼ˆåªå­˜å¯†æ–‡ï¼Œä¸å­˜å¯†é’¥ï¼‰

```python
# scripts/create_vault.py â€” ç¦»çº¿ä¸€æ¬¡æ€§è¿è¡Œï¼Œç”Ÿæˆ vault.enc
import json, getpass, os, base64
from cryptography.fernet import Fernet
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
from cryptography.hazmat.primitives import hashes

def derive_fernet(pw: str, salt: bytes) -> Fernet:
    kdf = PBKDF2HMAC(algorithm=hashes.SHA256(), length=32,
                     salt=salt, iterations=480_000)
    return Fernet(base64.urlsafe_b64encode(kdf.derive(pw.encode())))

salt      = os.urandom(16)
master_pw = getpass.getpass("Set Master Password: ")
plain     = {"acc001": "0xprivatekey001...", "acc002": "0xprivatekey002..."}
cipher    = derive_fernet(master_pw, salt).encrypt(json.dumps(plain).encode())

# vault æ ¼å¼ï¼šç¬¬1è¡Œ = salt hexï¼›ç¬¬2è¡Œ = Fernet å¯†æ–‡ï¼ˆæ— å¯†é’¥ï¼‰
with open("secrets/vault.enc", "wb") as f:
    f.write(salt.hex().encode() + b"\n" + cipher)
del master_pw, plain
```

### 4.3 SecretsVaultï¼ˆè¿›ç¨‹å†…å•ä¾‹ï¼‰

```python
# core/secrets_vault.py
import json, getpass, base64
from cryptography.fernet import Fernet
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
from cryptography.hazmat.primitives import hashes

class SecretsVault:
    _instance: "SecretsVault | None" = None

    def __init__(self):
        self._store: dict[str, str] = {}
        self._unlocked = False

    @classmethod
    def instance(cls) -> "SecretsVault":
        if cls._instance is None:
            cls._instance = SecretsVault()
        return cls._instance

    # â”€â”€ æ–¹æ¡ˆ Aï¼šå¯åŠ¨æ—¶ç»ˆç«¯è¾“å…¥ â”€â”€
    def unlock_interactive(self, vault_path: str = "secrets/vault.enc"):
        pw = getpass.getpass("ğŸ” Enter Master Password: ")
        self._load(vault_path, pw)
        del pw

    # â”€â”€ æ–¹æ¡ˆ Bï¼šTelegram Bot åŠ¨æ€ä¸‹å‘ â”€â”€
    async def unlock_via_telegram(self, vault_path: str,
                                  bot_token: str, chat_id: int):
        import asyncio, telegram
        bot = telegram.Bot(token=bot_token)
        await bot.send_message(chat_id=chat_id,
                               text="ğŸ” æ¡†æ¶å·²å¯åŠ¨ï¼Œè¯·å›å¤ Master Passwordï¼ˆæ¶ˆæ¯å°†è¢«ç«‹å³åˆ é™¤ï¼‰")
        last_id = 0
        for _ in range(300):
            await asyncio.sleep(1)
            for upd in await bot.get_updates(offset=last_id + 1, timeout=1):
                last_id = upd.update_id
                if upd.message and upd.message.chat_id == chat_id and upd.message.text:
                    pw = upd.message.text
                    await bot.delete_message(chat_id, upd.message.message_id)
                    self._load(vault_path, pw)
                    del pw
                    await bot.send_message(chat_id=chat_id, text="âœ… è§£é”æˆåŠŸï¼Œæ¶ˆæ¯å·²åˆ é™¤")
                    return
        raise TimeoutError("Vault unlock timeout (5 min)")

    def _load(self, vault_path: str, pw: str):
        with open(vault_path, "rb") as f:
            line1, cipher = f.read().split(b"\n", 1)
        salt   = bytes.fromhex(line1.decode())
        kdf    = PBKDF2HMAC(algorithm=hashes.SHA256(), length=32,
                             salt=salt, iterations=480_000)
        fernet = Fernet(base64.urlsafe_b64encode(kdf.derive(pw.encode())))
        plain  = fernet.decrypt(cipher)
        self._store    = json.loads(plain.decode())
        self._unlocked = True
        del plain

    def get_pk(self, account_id: str) -> str:
        if not self._unlocked:
            raise RuntimeError("SecretsVault not unlocked")
        return self._store[account_id]
```

### 4.4 å®‰å…¨è¾¹ç•Œè¯´æ˜

| å¨èƒ | æ˜¯å¦ç¼“è§£ | è¯´æ˜ |
|---|---|---|
| æ”»å‡»è€…æ‹¿åˆ° `vault.enc` | âœ… | æ—  Master Password æ— æ³•è§£å¯†ï¼ˆPBKDF2 480000æ¬¡ï¼Œæš´åŠ›ç ´è§£æˆæœ¬æé«˜ï¼‰ |
| æ”»å‡»è€…æ‹¿åˆ° `.env` | âœ… | `.env` ä¸å†å­˜ Master Passwordï¼Œåªå­˜ Bot Token ç­‰éå¯†é’¥é…ç½® |
| è¿›ç¨‹å‚æ•°å—…æ¢ | âœ… | å¯†ç é€šè¿‡ `getpass`/Telegram æ³¨å…¥ï¼Œä¸ä½œä¸º CLI å‚æ•° |
| è¿›ç¨‹å†…å­˜ dump | âŒ | ç§é’¥åœ¨ Python dict ä¸­ï¼›éœ€ OS çº§å†…å­˜åŠ å¯†ï¼ˆè¶…å‡ºæ¡†æ¶èŒƒå›´ï¼‰ |

---

## Patch 5ï¼šé¼ æ ‡è¡Œä¸ºç†µå€¼æå‡â€”â€”å¤šç­–ç•¥æ··åˆ {#patch-5}

**å½±å“ç« èŠ‚**ï¼šä¸»æ–‡æ¡£ Â§2 è®¾è®¡åŸåˆ™ã€Â§4.3 Layer 2A æ‰§è¡Œå¼•æ“  
**é—®é¢˜**ï¼š`ghost-cursor` å•ä¸€è´å¡å°”æ›²çº¿ç®—æ³•ä½¿ 100 ä¸ªè´¦å·äº§ç”Ÿç›¸åŒçš„æ•°å­¦æŒ‡çº¹ï¼ˆå¤šé¡¹å¼é˜¶æ•°/åŠ å‡é€Ÿæ¨¡å‹å›ºå®šï¼‰ã€‚Datadome ç­‰ç°ä»£é£æ§ä¼šæŠŠè¿™ç§"å®Œç¾æ‹Ÿäºº"æ ‡è®°ä¸ºç‰¹å®š Bot å˜ç§ã€‚

### 5.1 è®¾è®¡åŸåˆ™

```
ä¸è¿½æ±‚"å®Œç¾çš„äººç±»"ï¼Œè€Œæ˜¯è¿½æ±‚"è´¦å·é—´è¡Œä¸ºå·®å¼‚åº¦"ã€‚
æ¯ä¸ªè´¦å·ç»‘å®šå›ºå®šçš„ behavior_profile_idï¼Œå†³å®šç­–ç•¥æ¦‚ç‡æƒé‡â€”â€”
ä¸åŒè´¦å·çš„æƒé‡åˆ†å¸ƒä¸åŒï¼Œä¿è¯è·¨è´¦å·çš„è¡Œä¸ºå¤šæ ·æ€§ã€‚
```

### 5.2 å¤šç­–ç•¥æ··åˆå®ç°

```python
# core/behavior.py
import asyncio, random, math
from playwright.async_api import Page

# â”€â”€ 5 ç§ç§»åŠ¨ç­–ç•¥ â”€â”€

async def direct_move(page: Page, x: float, y: float):
    """ç›´çº¿å¿«é€Ÿï¼ˆæ•ˆç‡å‹ç”¨æˆ·ï¼‰ã€‚"""
    await page.mouse.move(x, y, steps=random.randint(3, 8))

async def bezier_move(page: Page, x: float, y: float):
    """éšæœºé˜¶è´å¡å°”ï¼ˆé˜¶æ•°/æ§åˆ¶ç‚¹å‡éšæœºï¼Œæ‰“ç ´å›ºå®šæ•°å­¦æŒ‡çº¹ï¼‰ã€‚"""
    steps = random.randint(15, 40)
    cur_x = random.uniform(0, 1280)   # å®é™…ä½¿ç”¨æ—¶ä» page.evaluate å–å½“å‰åæ ‡
    cur_y = random.uniform(0, 800)
    order = random.choice([2, 3])
    for i in range(1, steps + 1):
        t  = i / steps
        nx = cur_x + (x - cur_x) * t + random.uniform(-20, 20) * math.sin(t * math.pi)
        ny = cur_y + (y - cur_y) * t + random.uniform(-15, 15) * math.sin(t * math.pi)
        await page.mouse.move(nx, ny)
        await asyncio.sleep(random.uniform(0.004, 0.022))

async def overshoot_move(page: Page, x: float, y: float):
    """è¶…è°ƒå›æ­£ï¼ˆæ–°æ‰‹ç‰¹å¾ï¼Œçº¦ 30% çœŸå®ç”¨æˆ·å­˜åœ¨æ­¤è¡Œä¸ºï¼‰ã€‚"""
    ox = x + random.uniform(12, 35) * random.choice([-1, 1])
    oy = y + random.uniform(6, 20)  * random.choice([-1, 1])
    await page.mouse.move(ox, oy, steps=random.randint(8, 16))
    await asyncio.sleep(random.uniform(0.06, 0.18))
    await page.mouse.move(x, y, steps=random.randint(4, 9))

async def hesitate_move(page: Page, x: float, y: float):
    """åœé¡¿ä¿®æ­£å‹ï¼ˆåˆ†å¿ƒç”¨æˆ·ï¼šç§»ä¸€åŠåœä¸‹ï¼Œå†ç»§ç»­ï¼‰ã€‚"""
    mid_x = x * 0.5 + random.uniform(-25, 25)
    mid_y = y * 0.5 + random.uniform(-25, 25)
    await page.mouse.move(mid_x, mid_y, steps=random.randint(6, 12))
    await asyncio.sleep(random.uniform(0.15, 0.70))
    await page.mouse.move(x, y, steps=random.randint(5, 11))

async def miss_click_move(page: Page, x: float, y: float):
    """é«˜ç†µé”™è¯¯ï¼šä»¥ 30% æ¦‚ç‡å…ˆç‚¹åï¼Œå†ä¿®æ­£ï¼ˆæœ€æ¥è¿‘çœŸå®æ–°æ‰‹è¡Œä¸ºï¼‰ã€‚"""
    if random.random() < 0.30:
        await page.mouse.move(
            x + random.uniform(18, 45) * random.choice([-1, 1]),
            y + random.uniform(10, 28) * random.choice([-1, 1]),
            steps=random.randint(5, 11)
        )
        await asyncio.sleep(random.uniform(0.08, 0.28))
    await page.mouse.move(x, y, steps=random.randint(4, 10))


# â”€â”€ ç­–ç•¥åº“ä¸è´¦å· profile ç»‘å®š â”€â”€

STRATEGIES = [direct_move, bezier_move, overshoot_move, hesitate_move, miss_click_move]

BEHAVIOR_PROFILES: dict[str, list[float]] = {
    #                       Direct  Bezier  Overshoot  Hesitate  MissClick
    "efficient_v1":        [0.40,   0.40,   0.10,      0.05,     0.05],
    "casual_v1":           [0.10,   0.30,   0.25,      0.25,     0.10],
    "clumsy_v1":           [0.05,   0.20,   0.30,      0.30,     0.15],
    "default_v1":          [0.20,   0.40,   0.20,      0.15,     0.05],
}

async def human_move_and_click(page: Page, selector: str,
                               behavior_profile_id: str = "default_v1"):
    """ç»Ÿä¸€å…¥å£ï¼šé€‰ç­–ç•¥ â†’ ç§»åŠ¨ â†’ åœé¡¿ â†’ ç‚¹å‡»ã€‚"""
    elem = await page.wait_for_selector(selector)
    box  = await elem.bounding_box()
    if not box:
        await elem.click()
        return

    tx = box['x'] + box['width']  * random.uniform(0.28, 0.72)
    ty = box['y'] + box['height'] * random.uniform(0.28, 0.72)

    weights  = BEHAVIOR_PROFILES.get(behavior_profile_id, BEHAVIOR_PROFILES["default_v1"])
    strategy = random.choices(STRATEGIES, weights=weights, k=1)[0]
    await strategy(page, tx, ty)
    await asyncio.sleep(random.uniform(0.05, 0.22))   # ç‚¹å‡»å‰ç¡®è®¤åœé¡¿
    await page.mouse.click(tx, ty)
```

### 5.3 è´¦å· profile åˆ†é…å»ºè®®ï¼ˆ100 è´¦å·ï¼‰

```yaml
# å»ºè®®åˆ†å¸ƒï¼ˆä¸è¦è®©æ‰€æœ‰è´¦å·å…±äº«åŒä¸€ profileï¼‰
# accounts/acc001.yaml
behavior:
  behavior_profile_id: "clumsy_v1"

# åˆ†é…æ¯”ä¾‹å‚è€ƒï¼š
# efficient_v1  30 ä¸ªè´¦å·
# casual_v1     30 ä¸ªè´¦å·
# clumsy_v1     20 ä¸ªè´¦å·
# default_v1    20 ä¸ªè´¦å·
```

### 5.4 å…³äº isTrusted çš„è¯´æ˜

`isTrusted=false` æ˜¯æµè§ˆå™¨åŸç”Ÿæ ‡è®°åˆæˆäº‹ä»¶çš„å­—æ®µï¼ŒJS å±‚æ— æ³•ä¼ªé€ ã€‚  
**Zendriver åœ¨ CDP å±‚æ³¨å…¥é¼ æ ‡äº‹ä»¶ï¼Œ`isTrusted=true`**ï¼Œæ­¤é—®é¢˜åœ¨å½“å‰æŠ€æœ¯æ ˆä¸­æ— éœ€é¢å¤–å¤„ç†ã€‚  
é€€åŒ–åˆ°æ ‡å‡† Playwright `page.click()` æ—¶ä¼šäº§ç”Ÿ `isTrusted=false`ï¼›æœ¬æ¨¡å—ä½¿ç”¨ `page.mouse.move()` + `page.mouse.click()` è·¯å¾„ï¼ŒZendriver ä¸‹åŒæ ·ä¸º trustedã€‚

---

## æ–°å¢ä¾èµ–æ±‡æ€»

```diff
# requirements.txt è¿½åŠ 
+ web3>=7.0.0          # Patch 1ï¼šEVM é“¾äº¤äº’ä¸ Nonce ç®¡ç†
+ psutil>=5.9.0        # Patch 2ï¼šç³»ç»Ÿèµ„æºç›‘æ§

# ç§»é™¤ï¼ˆPatch 3 æ›¿ä»£ Synpressï¼‰
- package.json æ•´ä½“ï¼ˆ@synthetixio/synpress, @playwright/test, js-yamlï¼‰
```

## æ–°å¢ DB å˜æ›´æ±‡æ€»

| è¡¨/å­—æ®µ | å˜æ›´ | æ‰€å± Patch |
|---|---|---|
| `pending_txns` | æ–°å»ºè¡¨ï¼Œè¿½è¸ª Nonce å’Œé“¾ä¸Šäº¤æ˜“ç”Ÿå‘½å‘¨æœŸ | Patch 1 |
| `task_runs.failure_type` | æ–°å¢æšä¸¾å€¼ `nonce_stuck`ï¼ˆä¸å¯æ§ï¼‰ã€`resource_exhaustion`ï¼ˆä¸å¯æ§ï¼‰ | Patch 1/2 |

## ä¸»æ–‡æ¡£å˜æ›´å¯¹ç…§

| ä¸»æ–‡æ¡£ç« èŠ‚ | æœ¬è¡¥ä¸è¦†ç›–å†…å®¹ |
|---|---|
| Â§4.4 Layer 2B Web3 æ‰§è¡Œå¼•æ“ | Patch 1ï¼ˆNonce ç®¡ç†ï¼‰ã€Patch 3ï¼ˆMetaMask DOM æ›¿ä»£ Synpressï¼‰ |
| Â§4.2 Layer 1 è°ƒåº¦å¼•æ“ | Patch 2ï¼ˆResourceGuard å¹¶å‘ç†”æ–­ï¼‰ |
| Â§4.1 Layer 0 å®‰å…¨å­˜å‚¨ | Patch 4ï¼ˆSecretsVault ä¸è½ç›˜ï¼‰ |
| Â§2 + Â§4.3 Layer 2A | Patch 5ï¼ˆå¤šç­–ç•¥é¼ æ ‡è¡Œä¸ºæ··åˆï¼‰ |
| Â§9 ä¾èµ–æ¸…å• | æ–°å¢ web3/psutilï¼Œç§»é™¤ Node.js å…¨æ ˆ |

---

*è¡¥ä¸ç‰ˆæœ¬ï¼šv1.8 | æ—¥æœŸï¼š2026-02-19 | å¯¹åº”ä¸»æ–‡æ¡£ï¼šæ¡†æ¶è®¾è®¡æ–‡æ¡£_v1.md v1.7*
